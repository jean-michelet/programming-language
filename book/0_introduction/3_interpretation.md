# Interprétation

L'interprétation est le processus d'analyse, de traduction et d'exécution d'un code source en temps réel. Il existe plusieurs types d'interpréteurs, dont certains sont hybrides interpète/compilateur, chacun ayant ses avantages et ses 
inconvénients.

### *Tree-walker* interprète
Comme son nom l'indique, un **Tree-walker interpreter** traverse un AST et interpréte les 
instructions les unes à la suite des autres. Son principal avantage est qu'il est relativement 
*simple* à implémenter. En revanche, il est coûteux en mémoire car souvent composée d'un nombre importants 
de *noeuds* (***nodes*** *en anglais*) et long à interpréter de part sa structure arborescente.

### Machine virtuelle à byte codes
En pratique, les langages traditionnellement dits interprétés, tel que Javascript, sont de nos jours
très souvent compilés en une structure intermédiaire composée de codes octet (`byte codes`) exécutée par un interpréteur 
appelé machine virtuelle (*VM pour virtual machine en anglais*). Le but est de simuler le comportement d'un processeur tout en conservant la portabilité d'un tree-walker interpreter. Cela permet également d'avoir une structure moins 
coûteuse en mémoire mais surtout beaucoup plus rapide à éxecutée car elle consiste en une suite linéaire
d'instructions.

#### Exemple de génération de byte codes en ligne de commande avec Node :

Source :
```js
// javascript
function add(a, b) {
  return a + b
} 
```

Byte codes :
```
[generated bytecode for function: add (0x1a82f41784c1 <SharedFunctionInfo add>)]
...
Bytecode Age: 0
   20 S> 0x1a82f4178bd6 @    0 : 0b 04             Ldar a1
   29 E> 0x1a82f4178bd8 @    2 : 38 03 00          Add a0, [0]
   33 S> 0x1a82f4178bdb @    5 : a8                Return 
...
```
Les byte codes générés sont `Ldar a1`, `Add a0, [0]` et `Return`.

> Pour obtenir ce résultat, utiliser la commande `node --print-bytecode -e 'function add(a, b) {return a + b;} add(2, 2);'`.
> Il faut appeller `add` au moins une fois pour que sa déclaration soit compilé en byte codes.

*Lancé avec Node v16 au moment de l'écriture de ce chapitre.*

Un code similaire sous forme d'AST ressemblerait

### compilation JIT

Les moteurs de langages interprétés modernes sont souvent capables de compiler du code *à la volée*, on parle de compilation **JIT** (*just in time*).
Ce mécanisme est utile pour optimiser certaines portions de code pour lesquelles investir du temps de compilation en langage machine est rentable. Concrêtement, il s'agit souvent de compiler des byte codes en langage machine directement interprétable par le CPU. Historiquement, `V8` compilait directement le code source en langage machine [[8]](https://stackoverflow.com/a/69155309).

### Langage interprété ou compilé ?

La notion de langage interprété vs compilé devient donc de plus en plus ambigüe avec l'évolution des langages
traditionnellement interprétés mais gardez à l'esprit que, généralement, on parle de langage interprété quand 
le code n'a pas besoin d'être compilé *manuellement* par le développeur avant d'être mis en production comme 
c'est le cas, par exemple, pour les langages `c/c++` (code machine) ou bien `Java`, `C#` (byte codes).

Dans ce livre, nous allons développer un interpréteur de type *AST interpreter*. Si ce type d'interpréteur est souvent moins performant que les machines virtuelles à Byte Codes et peut être
plus gourmand en mémoire, il est plus simple à implémenter. Il permet tout aussi bien, voire plus
facilement de comprendre ce qu'est un environnement d'exécution, une
pile d'exécution (**callstack**), les **Jump statements** (`continue`, `break`, `return`, `throw`...).
